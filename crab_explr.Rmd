---
title: "Exploratory analysis of crab OA response"
author: ""
output: 
  html_document:
    code_folding: hide
    css: kable.css
self_contained: yes
runtime: shiny
---

```{r, message = F, warning = F}
library(knitr)
opts_chunk$set(warning = FALSE, message = FALSE, dev.args = list(bg = 'transparent', family = 'serif'), eval = T)

library(tidyverse)
library(glmulti)
library(MuMIn)
library(gridExtra)
library(Hmisc)
library(grid)
library(scales)
library(plotly)
library(kableExtra)

source('R/funcs.R')

data(crbs)
data(envdat)

# rename some variables
envdat <- envdat %>% 
  rename(
    pCO2_ave = pCO2, 
    pCO2 = pCO2.at.this.depth.not.depth.averaged
  )

# exp vars to use in reg mods
kpvars <- c('pH', 'Temperature', 'Aragonite')

# exp vars to use in cor eval
corvars <- c('pH', 'Temperature', 'Alkalinity', 'Salinity', 'Oxygen', 'Fluorescence', 'Nitrate', 'Phosphate', 'Silicate', 'Ammonia', 'pCO2_ave', 'pCO2', 'Aragonite', 'Revelle')
```

# {.tabset}

```{r}
selectInput(inputId = 'dep1', label = 'Select first depth:', choices = seq(10, 200, by = 10), selected = 30)

selectInput(inputId = 'dep2', label = 'Select second depth:', choices = seq(10, 200, by = 10), selected = 100)
```

```{r pairsplots, fig.height = 9, fig.width = 9}
# data prep, nested for mods
tocor <- reactive({
  
  # input
  dep1 <- as.numeric(input$dep1)
  dep2 <- as.numeric(input$dep2)
  
  out <- envdat %>% 
    filter(depth %in% c(dep1, dep2)) %>% 
    left_join(crbs, by = 'CTD') %>% 
    dplyr::select_(.dots = c('depth', 'abundances', 'Average.CL', corvars)) %>% 
    filter(Alkalinity > 2000) %>% 
    mutate(abundances = log(1 + abundances))
  
  return(out)
  
})
  
levs <- c(sort(corvars), sort(c('abundances', 'Average.CL')))
labs <- levs

dep1cor <- reactive({
  
  # input
  dep1 <- as.numeric(input$dep1)
  
  dep1cor <- tocor() %>% 
    filter(depth == dep1) %>% 
    select(-depth)
  
  dep1cor <- dep1cor[, rev(levs)]
  
  return(dep1cor)
  
})

dep2cor <- reactive({

  # input
  dep2 <- as.numeric(input$dep2)

  dep2cor <- tocor() %>%
    filter(depth == dep2) %>%
    select(-depth)

  dep2cor <- dep2cor[, rev(levs)]

  return(dep2cor)

})

```

## First selected depth

```{r fig.height = 8, fig.width = 8}
renderPlot({

  # inputs
  dep1 <- as.numeric(input$dep1)

  pairs(dep1cor(), gap = 0, cex = 1, col = 'grey', main = paste0('Env. data from ', dep1, ' m'), row1attop = F)

}, width = 700, height = 700)
```

```{r, fig.height = 7, fig.width = 7}
# all correlations
renderPlot({

  # input
  dep1cor <- dep1cor()

  crs <- crossing(var1 = names(dep1cor), var2 = names(dep1cor)) %>%
    filter(var1 != var2) %>%
    rownames_to_column() %>%
    group_by(rowname) %>%
    nest %>%
    mutate(
      crs = map(data, function(x){

        # variables
        vr1 <- dep1cor[[x$var1]]
        vr2 <- dep1cor[[x$var2]]

        # pearson
        pr_ts <- cor.test(vr1, vr2, method = 'pearson')
        pr_cr <- round(pr_ts$estimate, 2)
        pr_pv <- p_ast(pr_ts$p.value)
        pr <- paste(pr_cr, pr_pv)

        out <- data.frame(pr = pr, stringsAsFactors = F)
        return(out)

      })
    ) %>%
    unnest %>%
    select(-rowname)
  prplo <- crs %>%
    separate(pr, c('cor', 'sig'), sep = ' ') %>%
    filter(var1 %in% levs & var2 %in% levs) %>%
    mutate(
      cor = as.numeric(cor),
      var1 = factor(var1, levels = rev(levs), labels = rev(labs)),
      var2 = factor(var2, levels = rev(levs), labels = rev(labs)),
      sig = gsub('ns', '', sig)
    )

  pbase <- theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 8),
      axis.text.y = element_text(size = 8),
      legend.position = c(0.5, 1.1),
      legend.direction = 'horizontal',
      plot.margin = unit(c(6,4,0,0), "lines"),
      strip.background = element_blank(),
      strip.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5),
      panel.background = element_rect(fill = 'black')
    )

  outlab <- data.frame(
    y = c(1.5, 9.5),
    lab = c('Biological', 'Environment')
  )

  p <- ggplot(prplo) +
    geom_tile(aes(y = var1, x = var2, fill = cor), colour = 'black') +
    geom_text(aes(y = var1, x = var2, label = sig)) +
    annotation_custom(grob = textGrob(label = outlab$lab[1], hjust = 0, gp = gpar(cex = 0.7)),
                      ymin = outlab$y[1], ymax = outlab$y[1], xmin = 17, xmax = 17) +
    annotation_custom(grob = textGrob(label = outlab$lab[2], hjust = 0, gp = gpar(cex = 0.7)),
                      ymin = outlab$y[2], ymax = outlab$y[2], xmin = 17, xmax = 17) +
    annotation_custom(grob = textGrob(label = outlab$lab[1], hjust = 0.5, gp = gpar(cex = 0.7)),
                      xmin = outlab$y[1], xmax = outlab$y[1], ymin = 17, ymax = 17) +
    annotation_custom(grob = textGrob(label = outlab$lab[2], hjust = 0.5, gp = gpar(cex = 0.7)),
                      xmin = outlab$y[2], xmax = outlab$y[2], ymin = 17, ymax = 17) +
    pbase +
    scale_y_discrete('', expand = c(0, 0), labels = parse(text = rev(labs))) +
    scale_x_discrete('', expand = c(0, 0), labels = parse(text = rev(labs))) +
    scale_fill_gradient2('Correlation', low = muted("blue"), mid = "white", high = muted("red"), midpoint = 0) +
    geom_hline(yintercept = 2.5, size = 1.5) +
    geom_vline(xintercept = 2.5, size = 1.5)

  # Code to override clipping
  gt <- ggplot_gtable(ggplot_build(p))
  gt$layout$clip[gt$layout$name == "panel"] <- "off"
  grid.draw(gt)

}, width = 700, height = 700)

```

## Second selected depth

```{r fig.height = 8, fig.width = 8}
renderPlot({

  # inputs
  dep2 <- as.numeric(input$dep2)

  pairs(dep2cor(), gap = 0, cex = 1, col = 'grey', main = paste0('Env. data from ', dep2, ' m'), row1attop = F)

}, width = 800, height = 800)
```

```{r, fig.height = 7, fig.width = 7}
# all correlations
renderPlot({

  # input
  dep2cor <- dep2cor()

  crs <- crossing(var1 = names(dep2cor), var2 = names(dep2cor)) %>%
    filter(var1 != var2) %>%
    rownames_to_column() %>%
    group_by(rowname) %>%
    nest %>%
    mutate(
      crs = map(data, function(x){

        # variables
        vr1 <- dep2cor[[x$var1]]
        vr2 <- dep2cor[[x$var2]]

        # pearson
        pr_ts <- cor.test(vr1, vr2, method = 'pearson')
        pr_cr <- round(pr_ts$estimate, 2)
        pr_pv <- p_ast(pr_ts$p.value)
        pr <- paste(pr_cr, pr_pv)

        out <- data.frame(pr = pr, stringsAsFactors = F)
        return(out)

      })
    ) %>%
    unnest %>%
    select(-rowname)
  levs <- c(sort(corvars), sort(c('abundances', 'Average.CL')))
  labs <- levs
  prplo <- crs %>%
    separate(pr, c('cor', 'sig'), sep = ' ') %>%
    filter(var1 %in% levs & var2 %in% levs) %>%
    mutate(
      cor = as.numeric(cor),
      var1 = factor(var1, levels = rev(levs), labels = rev(labs)),
      var2 = factor(var2, levels = rev(levs), labels = rev(labs)),
      sig = gsub('ns', '', sig)
    )

  pbase <- theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 8),
    axis.text.y = element_text(size = 8),
    legend.position = c(0.5, 1.1),
    legend.direction = 'horizontal',
    plot.margin = unit(c(6,4,0,0), "lines"),
    strip.background = element_blank(),
    strip.text.y = element_text(angle = 0, hjust = 0, vjust = 0.5),
    panel.background = element_rect(fill = 'black')
    )

  outlab <- data.frame(
    y = c(1.5, 9.5),
    lab = c('Biological', 'Environment')
  )

  p <- ggplot(prplo) +
    geom_tile(aes(y = var1, x = var2, fill = cor), colour = 'black') +
    geom_text(aes(y = var1, x = var2, label = sig)) +
    annotation_custom(grob = textGrob(label = outlab$lab[1], hjust = 0, gp = gpar(cex = 0.7)),
                      ymin = outlab$y[1], ymax = outlab$y[1], xmin = 17, xmax = 17) +
    annotation_custom(grob = textGrob(label = outlab$lab[2], hjust = 0, gp = gpar(cex = 0.7)),
                      ymin = outlab$y[2], ymax = outlab$y[2], xmin = 17, xmax = 17) +
    annotation_custom(grob = textGrob(label = outlab$lab[1], hjust = 0.5, gp = gpar(cex = 0.7)),
                      xmin = outlab$y[1], xmax = outlab$y[1], ymin = 17, ymax = 17) +
    annotation_custom(grob = textGrob(label = outlab$lab[2], hjust = 0.5, gp = gpar(cex = 0.7)),
                      xmin = outlab$y[2], xmax = outlab$y[2], ymin = 17, ymax = 17) +
    pbase +
    scale_y_discrete('', expand = c(0, 0), labels = parse(text = rev(labs))) +
    scale_x_discrete('', expand = c(0, 0), labels = parse(text = rev(labs))) +
    scale_fill_gradient2('Correlation', low = muted("blue"), mid = "white", high = muted("red"), midpoint = 0) +
    geom_hline(yintercept = 2.5, size = 1.5) +
    geom_vline(xintercept = 2.5, size = 1.5)

  # Code to override clipping
  gt <- ggplot_gtable(ggplot_build(p))
  gt$layout$clip[gt$layout$name == "panel"] <- "off"
  grid.draw(gt)

}, width = 700, height = 700)

```

# {.tabset}

## Models

```{r}
##
# prep data for modelling

# model globals
resp <- c(
    abundances = 'log(1+val)',
    pa = 'val',
    Average.CL = 'val'
  ) %>%
  enframe('res', 'resp') %>%
  group_by(res) %>%
  nest(.key = 'resp') %>%
  mutate(
    resp = map(resp, ~ paste(.x, paste(kpvars, collapse = '+'), sep = '~'))
    )
fams <- list(
    abundances = 'gaussian',
    pa = 'binomial',
    Average.CL = 'gaussian'
  ) %>%
  enframe('res', 'dist')

# data prep, nested for mods
tomod <- reactive({

  # input
  dep1 <- as.numeric(input$dep1)
  dep2 <- as.numeric(input$dep2)

  envdat %>%
    filter(depth %in% c(dep1, dep2)) %>%
    left_join(crbs, by = 'CTD') %>%
    select(-diss) %>%
    gather('var', 'val', -CTD, -abundances, -pa, -Average.CL, -depth) %>%
    group_by(var) %>%
    mutate(
      val = scale(val)
    ) %>%
    spread(var, val) %>%
    dplyr::select_(.dots = c('depth', 'abundances', 'pa', 'Average.CL', kpvars)) %>%
    gather('res', 'val', abundances, pa, Average.CL) %>%
    dplyr::select(depth, res, val, everything()) %>%
    # filter(Alkalinity > -2) %>%
    group_by(depth, res) %>%
    nest %>%
    left_join(fams, by = 'res') %>%
    left_join(resp, by = 'res')

})
```

```{r}
##
# model selection

mods <- reactive({

  # input
  tomod <- tomod()

  tops <- vector('list', length = nrow(tomod))
  cffs <- vector('list', length = nrow(tomod))

  for(i in 1:nrow(tomod)){

    x <- tomod[i, ] %>%
      .[['data']] %>%
      .[[1]] %>%
      filter(!is.na(val))

    resp <- tomod[i, ] %>%
      pull(resp) %>%
      .[[1]]

    dist <- tomod[i, ] %>%
      pull(dist) %>%
      .[[1]]

    cffsmlt <- do.call('glmulti',
                    list(formula(resp), data = x, level = 1, method = 'h', crit = 'aicc', plotty = F, report = F, fitfunction = 'glm', family = dist)) %>%
      coef %>%
      data.frame %>%
      rownames_to_column('var')

    # global glm
    globs <- paste0('glm(', resp, ', data = x, na.action = na.pass, family = "', dist, '")') %>%
      parse(text = .) %>%
      eval

    # dredge, get sum stats manually
    drdg <- dredge(globs)
    drdgsub <- get.models(drdg, subset = 1:5) %>%
      map(., function(x){

        # get mod prm, pval
        out <- x %>% summary %>% coef %>% data.frame %>% rownames_to_column('var') %>%
          .[, c(1, 2, 5)]
        names(out)[3] <- 'pval'
        out <- out %>%
          mutate(
            Estimate = round(Estimate, 2),
            pval = p_ast(pval)
            ) %>%
          unite('Estimate', Estimate, pval, sep = '') %>%
          spread(var, Estimate)

        # get sum stats
        llk <- logLik(x)
        out <- out %>%
           mutate(
            df = attr(llk, 'df'),
            loglik = llk[1],
            aicc = aicc(x)
          )

        return(out)
      }) %>%
      enframe %>%
      unnest %>%
      mutate(
        model = 1:n(),
        delta = aicc - aicc[1]
        ) %>%
      select(model, df, loglik, aicc, delta, everything()) %>%
      select(-name) %>%
      gather('var', 'val', -model, -df, -loglik, -aicc, -delta) %>%
      spread(var, val, fill = '-') %>%
      mutate(
        aicc = round(aicc, 2),
        loglik = round(loglik, 2),
        delta = round(delta, 2)
      )

    tops[[i]] <- drdgsub
    cffs[[i]] <- cffsmlt

  }

  # models
  mods <- tomod %>%
    select(depth, res) %>%
    mutate(
      tops = tops,
      cffs = cffs
    )

  return(mods)

})

```

```{r fig.height = 8, fig.width = 8}

renderPlot({

  # input
  mods <- mods()

  # toplot
  toplo <- mods %>%
    select(-tops) %>%
    unnest %>%
    filter(!var %in% '(Intercept)') %>%
    mutate(
      `Depth (m)` = factor(depth),
      res = factor(res,
                   levels = c('abundances', 'pa', 'Average.CL'),
                   labels = c('Abundance', 'Pres./Abs.', 'Ave. carapace length'))
      )
  names(toplo) <- gsub('\\.*', '', names(toplo))

  thm <- theme_bw(base_family = 'serif', base_size = 14) +
    theme(
      strip.background = element_blank(),
      legend.position = 'top',
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )

  # importance
  toplo1 <- toplo %>%
    group_by(res) %>%
    arrange(depth, -Importance) %>%
    mutate(var = factor(var, levels = unique(var)))
  p1 <- ggplot(toplo1, aes(x = var, y = Importance, fill = `Depth (m)`, group = `Depth (m)`)) +
    geom_bar(stat = 'identity', position = 'dodge', colour = 'black') +
    facet_wrap(~ res, ncol = 1,scales = 'free_y') +
    thm +
    theme(legend.position = 'none') +
    ggtitle('Variable\nimportance') +
    scale_fill_manual(values = c('lightgrey', 'darkgrey'))

  # estimates
  toplo2 <- toplo %>%
    group_by(res) %>%
    arrange(depth, -Estimate) %>%
    mutate(var = factor(var, levels = unique(var)))
  p2 <- ggplot(toplo2, aes(x = var, y = Estimate, group = `Depth (m)`, fill = `Depth (m)`)) +
    geom_bar(stat = 'identity', position = 'dodge', colour = 'black') +
    geom_hline(yintercept = 0) +
    # geom_errorbar(aes(ymin = Estimate - Xalpha005, ymax = Estimate + Xalpha005, group = `Depth (m)`), position = 'dodge') +
    facet_wrap(~ res, scales = 'free_y', ncol = 1) +
    thm +
    ggtitle('Pooled parameter\nestimates') +
    scale_fill_manual(values = c('lightgrey', 'darkgrey'))
  pleg <- g_legend(p2)
  p2 <- p2 + theme(legend.position = 'none')

  # unconditional variance
  toplo3 <- toplo %>%
    group_by(res) %>%
    arrange(depth, -Uncondvariance) %>%
    mutate(var = factor(var, levels = unique(var)))
  p3 <- ggplot(toplo3, aes(x = var, y = Uncondvariance, group = `Depth (m)`, fill = `Depth (m)`)) +
    geom_bar(stat = 'identity', position = 'dodge', colour = 'black') +
    facet_wrap(~ res, scales = 'free_y', ncol = 1) +
    thm +
    ggtitle('Unconditional explained\nvariance (%)') +
    scale_fill_manual(values = c('lightgrey', 'darkgrey'))
  pleg <- g_legend(p3)
  p3 <- p3 + theme(legend.position = 'none')

  grid.arrange(
    pleg,
    arrangeGrob(p1, p3, p2, ncol = 3),
    ncol = 1, heights = c(0.1, 1)
  )

}, width = 700, height = 700)
```

Results of model selection analysis with three crab population variables (abundance, presence/absence, carapace length) by shallow and deep water. Variable importances and pooled estimates show summarized results from multiple models that evaluated all parameter combinations.  The unconditional explained variance (%) is the effect of each variable independent of all other variables.

### Top models in tabular {.tabset}

```{r}
##
# tables of top mods

# tabular
totab <- reactive({

  mods() %>%
    select(-cffs)

})
```

#### Abundance

```{r, results = 'asis'}
# abundance table
renderUI({

  # input
  totab <- totab()

  abutab <- totab %>%
    filter(res %in% 'abundances') %>%
    select(-res) %>%
    unnest %>%
    mutate(depth = paste(depth, 'm'))

  cap.val<-paste0('Top five selected models for crab abundance at shallow and deep water. Input variables were ', paste(tolower(sort(kpvars)), collapse = ', '), '. All explanatory variables were scaled and centered.')
  cap.val <- gsub('^(.*), (.*)$', '\\1, and \\2', cap.val)

  HTML(knitr::kable(abutab, caption = cap.val, results = 'html') %>% 
    kable_styling(full_width = T, font_size = 14))

})
```

#### Presence/absence

```{r, results = 'asis'}
# pa table
renderUI({

  # input
  totab <- totab()

  patab <- totab %>%
    filter(res %in% 'pa') %>%
    select(-res) %>%
    unnest

  cap.val<-paste0('Top five selected models for crab presence/absence at shallow and deep water. Input variables were ', paste(tolower(sort(kpvars)), collapse = ', '), '. All explanatory variables were scaled and centered.')
  cap.val <- gsub('^(.*), (.*)$', '\\1, and \\2', cap.val)

  HTML(knitr::kable(patab, caption = cap.val, format = 'html')%>% 
    kable_styling(full_width = T, font_size = 14))

})
```

#### Carapace length

```{r, results = 'asis'}
# carapace length table
renderUI({

  # input
  totab <- totab()

  cltab <- totab %>%
    filter(res %in% 'Average.CL') %>%
    select(-res) %>%
    unnest

  cap.val<-paste0('Top five selected models for crab carapace length at shallow and deep water. Input variables were ', paste(tolower(sort(kpvars)), collapse = ', '), '.  All explanatory variables were scaled and centered.')
  cap.val <- gsub('^(.*), (.*)$', '\\1, and \\2', cap.val)

  HTML(knitr::kable(cltab, caption = cap.val, results = 'html') %>% 
    kable_styling(full_width = T, font_size = 14))

})
```


## Dissolution factor analysis

```{r, fig.height = 12, fig.width = 3}

discomp <- reactive({
  
  # input
  dep1 <- as.numeric(input$dep1)
  dep2 <- as.numeric(input$dep2)
  
  discomp <- envdat %>%
    filter(depth %in% c(dep1, dep2)) %>%
    left_join(crbs, by = 'CTD') %>%
    dplyr::select_(.dots = c('depth', 'abundances', 'Average.CL', 'diss', corvars)) %>%
    mutate(
      abundances = log(1 + abundances),
      diss = factor(diss, levels = c('none', 'lo', 'hi'))
      ) %>%
    filter(!is.na(diss)) %>%
    gather('var', 'val', -depth, -diss) %>%
    filter(!is.na(val))
  
  return(discomp)
  
})

# discompave <- discomp %>%
#   group_by(depth, diss, var) %>%
#   summarise(val = mean(val))
# 
# p <- ggplot(discomp, aes(x = diss, y = val)) +
#   geom_jitter(width = 0.1, alpha = 0.6) +
#   geom_path(data = discompave, aes(group = var)) +
#   facet_grid(var ~ depth, scales = 'free_y', switch = 'y') +
#   theme_bw() +
#   theme(
#     strip.background = element_blank(),
#     axis.title.y = element_blank(),
#     strip.placement = 'outside'
#   ) +
#   ggtitle('Depths (m)')
# p
```

```{r}
# t-tests
ttsts <- reactive({
  
  ttsts <- discomp() %>%
    group_by(depth, var) %>%
    nest %>%
    mutate(ttst = map(data, function(x){
  
      if(length(unique(x$diss)) == 2)
        t.test(val ~ diss, x)
      else
        lm(val ~ diss, x)
  
    }))
  
  return(ttsts)
  
})

renderUI({
  
  chcs <- unique(ttsts()$var)
  
  selectInput("var", "Choose variable:", chcs)  
  
})


# select data from t-tests
ttstshw <- reactive({

  dat <- filter(ttsts(), var %in% input$var) %>%
    .$ttst

  if(inherits(dat[[2]], 'lm'))
    dat[[2]] <- summary(dat[[2]])

  return(dat)

})

# select data to plot
ttstplo <- reactive({

  dat <- filter(ttsts(), var %in% input$var) %>%
    select(-ttst) %>%
    unnest

})

# plot of individual variable by dissolution
renderPlot({

  toplo <- ttstplo()

  toploave <- toplo %>%
    group_by(depth, diss, var) %>%
    summarise(val = mean(val))

  ggplot(toplo, aes(x = diss, y = val)) +
    geom_jitter(width = 0.1, alpha = 0.6, size = 4) +
    geom_path(data = toploave, aes(group = var)) +
    facet_grid(var ~ depth, scales = 'free_y', switch = 'y') +
    theme_bw(base_size = 18) +
    theme(
      strip.background = element_blank(),
      axis.title.y = element_blank(),
      strip.placement = 'outside'
    ) +
    ggtitle('Depths (m)')

}, height = 300, width = 600)

renderPrint({cat(input$dep1, "m test\n");ttstshw()[[1]]})
renderPrint({cat(input$dep2, "m test\n");ttstshw()[[2]]})
```

## Optimal environmental factors for abundance

```{r envoptprp}

# abundance data to join with depsub below
abus <- crbs %>%
  select(CTD, abundances) %>%
  na.omit %>%
  mutate(abundances = log(1 + abundances))

# nested tibble with six columns
# dep: depth value to subset data
# vr: which env var that was evaluated
# depsub: data subset by dep and vr
# mod: nls model of abundance by vr
# opt: optimal values for env vr from nls model (min, opt, max)
# plo: a plot of the model fit for depsub
resopt <- crossing(
  dep = seq(10, 200, length = 20),
  vr = kpvars
  ) %>%
  mutate(

    # data filtered by dep, vr
    depsub = pmap(list(dep, vr), function(dep, kpvars){

      # get depth integrated data
      depsub <- envdat %>%
        dplyr::select_(.dots = c('depth', 'CTD', kpvars)) %>%
        filter(depth == dep) %>%
        gather('var', 'val', -depth, -CTD) %>%
        arrange(CTD, depth) %>%
        left_join(abus, by = 'CTD')

      return(depsub)

    }),

    # nls mod on depsub
    mod = map(depsub, function(depsub){

      avestr <- mean(depsub$val, na.rm = T)
      sdstr <- sd(depsub$val, na.rm = T)
      mod <- try({
        nls(abundances ~ k*exp(-1/2*(val-mu)^2/sigma^2), start=c(mu=avestr,sigma=sdstr,k=1) , data = depsub)
      })

      if(inherits(mod, 'try-error'))
        return(NA)

      return(mod)

    }),

    # opt values from model
    opt = map(mod, function(mod){

      if(anyNA(mod))
        return(NA)

      coffs <- coefficients(mod)
      muval <- coffs['mu']
      sival <- coffs['sigma']

      opt <- qnorm(c(0.05, 0.5, 0.95), muval, sival)

      return(opt)

    }),

    # plot on model with depsub
    plo = pmap(list(depsub, mod, opt, vr), function(depsub, mod, opt, vr){

      if(anyNA(mod))
        return(NA)

      valrng <- range(depsub$val, na.rm = T)
      prddat <- seq(min(valrng), max(valrng), length = 100) %>%
        data.frame(val = .)
      fitdt <- predict(mod, newdata = prddat)
      prddat <- data.frame(prddat, abundances = fitdt)

      plo <- ggplot(depsub, aes(x = val, y = abundances)) +
        geom_point() +
        geom_line(data = prddat) +
        geom_vline(xintercept = opt, color = 'red') +
        scale_x_continuous(vr) +
        scale_y_continuous("log-abundance") +
        theme_bw(base_family = 'serif')

      return(plo)

    })

  )
```
```{r}
selectInput("vr", "Choose variable:", choices = unique(resopt$vr), selected = 'Temperature')
selectInput("dep", "Choose depth:", choices = unique(resopt$dep), selected = '50')

renderPlot({

  vr <- input$vr
  dep <- input$dep

  toplo <- resopt %>%
    filter(vr == input$vr & dep == input$dep) %>%
    pull(plo) %>%
    .[[1]]

  return(toplo)

})

```


```{r}


cumest <- resopt %>%
  select(dep, vr, opt) %>%
  mutate(opt = map(opt, function(opt){

    out <- matrix(opt, ncol = 3) %>%
      as.data.frame
    names(out) <- c('min', 'opt', 'max')

    return(out)

    })
  ) %>%
  unnest %>%
  gather('est', 'opt', -dep, -vr)

ggplot(cumest, aes(x = opt, y = dep, group = est,  colour = est)) +
  geom_point() +
  geom_path() +
  scale_y_reverse() +
  facet_wrap(~vr, scales = 'free_x')

```

